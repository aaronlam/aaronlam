<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何修改Git Commit的描述</title>
    <url>/2018/10/30/amend-git-committed-comment/</url>
    <content><![CDATA[<p>使用 Git 进行项目的版本管理，的确是能让项目代码更加的受控。但是如果能有清晰的 commit 记录以及描述，那将更是会锦上添花。在需求正常开发完后，有时难免会过于兴奋手滑敲错 commit 的描述。但如果对于不经常手滑的同学来说，可能还没研究过如何修改 commit 的描述。所以今天，我就想通过这一篇文章简单的记录一下 commit 描述的修改过程，顺便给自己留作回顾的作用。</p>
<p>修改 commit 描述分为以下两种情况，但这两种情况步骤基本相同，只是第二种需要在最后多加一步操作：</p>
<ol>
<li>还未将代码 push 到远程仓库</li>
<li>已将代码 push 到远程仓库</li>
</ol>
<a id="more"></a>

<h1 id="修改最后一次-commit-的描述"><a href="#修改最后一次-commit-的描述" class="headerlink" title="修改最后一次 commit 的描述"></a>修改最后一次 commit 的描述</h1><p>如果只是想修改最后一次 commit 后的描述，可以直接在命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>输入完后，会出现以下界面（commit 的描述位于界面的第一行）：</p>
<ol>
<li>按 <kbd>i</kbd> 键进入命令行的修改模式，修改位于界面第一行的 commit 描述</li>
<li>修改完后，按 <kbd>Esc</kbd> 键退出命令行的编辑模式</li>
<li>再输入 <code>:wq</code> 保存并退出，至此 commit 的描述就修改成功啦！</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201028225408.png" alt="修改最后一次commit的描述"></p>
<h1 id="修改之前某次-commit-的描述"><a href="#修改之前某次-commit-的描述" class="headerlink" title="修改之前某次 commit 的描述"></a>修改之前某次 commit 的描述</h1><p>如果是想修改之前某次 commit 的描述，则需要比修改最后一次 commit 的描述多上那么几个步骤。其实这个修改的原理，按我的理解就是先把版本回退到你想修改的某个版本，然后再修改当前回退到的版本的 commit 描述，修改完后再回到回退前的最新版本中。那么来吧！</p>
<p>首先在命令行输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令中最后的数字2指的是显示倒数第几次的commit，比如我这里的2就代表显示倒数第二次的commit描述</span></span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>

<p>输入完后，会出现以下界面（倒数几次的 commit 的描述都位于界面顶部）：</p>
<ol>
<li>想修改哪条 commit 的描述，就把该条 commit 描述前的 <strong>pick</strong> 改成 <strong>edit</strong>（修改的方式同上）</li>
<li>修改完后按 <kbd>Esc</kbd> 键退出命令行的编辑模式，</li>
<li>输入 <code>:wq</code> 保存并退出。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201028233014.png" alt="修改之前某次commit的描述1"></p>
<p>保存并退出后，会出现以下界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201028234716.png" alt="修改之前某次commit的描述2"></p>
<p>然后，再往命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>输入完后，就如同上面那样修改完描述，然后保存并退出后，再往命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<h1 id="修改之前的某几次-commit-的描述"><a href="#修改之前的某几次-commit-的描述" class="headerlink" title="修改之前的某几次 commit 的描述"></a>修改之前的某几次 commit 的描述</h1><p>修改之前某几次其实和上面修改某次的步骤差不多，不同之处在于以下几点：</p>
<ol>
<li>上面，第一个步骤中的命令，数字需要修改</li>
<li>然后在修改 <strong>pick</strong> 为 <strong>edit</strong> 的那一个步骤时，修改多个</li>
<li>最后依次修改描述（顺序是从旧到新），命令行中基本都会提示你接下来的操作是什么，每次修改一个注释都需要重复上面的最后两个步骤，直至修改完你所标记为 <strong>edit</strong> 的所有描述为止</li>
</ol>
<h1 id="已经将代码-push-到远程仓库"><a href="#已经将代码-push-到远程仓库" class="headerlink" title="已经将代码 push 到远程仓库"></a>已经将代码 push 到远程仓库</h1><p>在已经把代码 push 到远程仓库的情况下，还想修改 commit 的描述的话，在修改前首先需要从远程仓库 pull 最新的版本到本地仓库，确保两边的版本都是一致的状态。然后再按照情况，选择上面的几种方法来进行修改。最后，修改完需要再强制把本地仓库的版本 push 回远程仓库中。<strong>但很重要的一点是，在进行强制 push 之前，需要再三确认没有人往远程仓库提交更新的版本，否则远程仓库中更新的版本将会被你的版本所覆盖。</strong></p>
<p>在命令行中输入以下命令，强制 push 本地仓库版本到远程仓库中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<p>大功告成！</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS Module和ES6 Modules之间的引用与转换</title>
    <url>/2019/10/05/commonjs-and-es6-modules/</url>
    <content><![CDATA[<p>平时在项目开发的过程中，因为 JavaScript 模块化的历史遗留问题，难免会存在在 CommonJS 的模块里头 <code>import</code> ES6 的模块，或者在 CommonJS 的模块里头 <code>require</code> ES6 的模块的情况发生。为了能够搞清楚他们之间的转换小秘密，所以就专门记录一下，方便日后回顾，顺便上来水一文。</p>
<blockquote>
<p>因为这两种模块在网络上存在着各式各样的叫法，所以在文章开始前，为了能够和大家达成一致的共识。在后面我将会用 <strong>CJS</strong> 代指 CommonJS Module，用 <strong>ESM</strong> 代指 ES Modules。</p>
</blockquote>
<h1 id="ESM-转-CJS"><a href="#ESM-转-CJS" class="headerlink" title="ESM 转 CJS"></a>ESM 转 CJS</h1><h2 id="1-ESM-export-转-CJS-exports"><a href="#1-ESM-export-转-CJS-exports" class="headerlink" title="1. ESM export 转 CJS exports"></a>1. ESM export 转 CJS exports</h2><p>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>a.js</code> 中的 <strong>ESM</strong> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<blockquote>
<p>注：在 ESM 被转为 CJS 时，转译器会在其导出的对象中定义一个值为 <code>true</code> 的私有的变量 <code>__esModule</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.func = func;</span><br><span class="line"><span class="keyword">var</span> foo = (<span class="built_in">exports</span>.foo = <span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">exports</span>.default = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其实也就等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.__esModule = <span class="literal">true</span>; <span class="comment">// 该属性实际上会通过Object.defineProperty API设置为不可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">exports</span>.default = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="2-ESM-import-转-CJS-require"><a href="#2-ESM-import-转-CJS-require" class="headerlink" title="2. ESM import 转 CJS require"></a>2. ESM import 转 CJS require</h2><h3 id="2-1-Default-import"><a href="#2-1-Default-import" class="headerlink" title="2.1 Default import"></a>2.1 Default import</h3><p>还是一个栗子，直接默认导入 <code>a.js</code> 中的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p><code>b.js</code> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> _a2 = _interopRequireDefault(_a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是ESM则直接返回obj，否则返回带有default属性的新对象</span></span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(_a2.default);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Wildcard-import"><a href="#2-2-Wildcard-import" class="headerlink" title="2.2 Wildcard import"></a>2.2 Wildcard import</h3><p>再一个栗子，名字空间导入 <code>a.js</code> 中的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p><code>b.js</code> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> A = _interopRequireWildcard(_a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireWildcard</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ESM直接返回obj</span></span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.__esModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// CJS的话就创建一个新的空对象，并把obj内的所有自有属性都浅复制到新对象中，最后再把obj赋值给新对象的default属性</span></span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">          newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newObj.default = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol>
<li>ESM 的 <code>export</code> 相当于往 CJS 的 <code>exports</code> 上添加属性<ol>
<li><code>export var/let/const/function/class...</code> 会往 <code>exports</code> 上添加同名属性</li>
<li><code>export default</code> 会往 <code>exports</code> 上添加 default 属性</li>
</ol>
</li>
<li>ESM 可以 <strong>default</strong> <code>import</code> 和 <strong>wildcard</strong> <code>import</code> CJS<ol>
<li><strong>default</strong> <code>import</code> CJS 时，会创建一个新的空对象，并把 CJS 的导出对象 <code>exports</code> 赋值到新对象的 default 属性</li>
<li><strong>wildcard</strong> <code>import</code> CJS 时，会创建一个新的空对象，并把 CJS 的导出对象 <code>exports</code> 中的自有属性浅复制到新的空对象中，最后再把导出对象 <code>exports</code> 赋值到新对象的 default 属性</li>
</ol>
</li>
</ol>
<h1 id="ESM-中引用-CJS"><a href="#ESM-中引用-CJS" class="headerlink" title="ESM 中引用 CJS"></a>ESM 中引用 CJS</h1><p>根据上面得出的结论，ESM 中引用 CJS 有两种方式，栗子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  <span class="keyword">default</span>: <span class="string">&quot;myDefault&quot;</span>,</span><br><span class="line">  foo: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// esm.js</span></span><br><span class="line"><span class="keyword">import</span> cjs <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs = (&#123; default: exports &#125;).default;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cjs2 <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs2 = (&#123; ...exports, default: exports &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> cjs3 &#125; <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs3 = (&#123; default: exports &#125;).default</span></span><br></pre></td></tr></table></figure>

<h1 id="CJS-中引用-ESM"><a href="#CJS-中引用-ESM" class="headerlink" title="CJS 中引用 ESM"></a>CJS 中引用 ESM</h1><p>在 CJS 中引用 ESM 相当于直接引用 ESM 转成 CJS 的 <code>module.exports</code>，栗子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">cls</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">var</span> es = <span class="built_in">require</span>(<span class="string">&quot;./es&quot;</span>);</span><br><span class="line"><span class="comment">/* es结构如下：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    foo,</span></span><br><span class="line"><span class="comment">    bar: foo,</span></span><br><span class="line"><span class="comment">    func,</span></span><br><span class="line"><span class="comment">    cls,</span></span><br><span class="line"><span class="comment">    default: 1</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JacaScript</tag>
        <tag>ESModules</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>更优雅的JavaScript 1</title>
    <url>/2019/12/13/more-elegant-javascript-1/</url>
    <content><![CDATA[<p>貌似，现在大家写代码都只是在追求其极致性能、精巧体积、华丽技巧，而忽视了最重要的”<strong>code for hunmans</strong>“。</p>
<p>我们知道在日常项目开发时，代码被人阅读的难度是远高于执行引擎的。所以要写出好的代码就需要尝试脱离自己的视角，以第三人的眼光重新审视、理解其上下文的含义。 这样创作出的代码结构、组合、技巧才会予人阅读的幸福感。我们致力于书写优秀的代码就意味着，代码不仅仅是一个工具，更是将其视作为用来传达精神、思想、理念的一座桥梁。这是一种对于书写者智慧的锤炼与分享。</p>
<a id="more"></a>

<h1 id="1-优先使用-const"><a href="#1-优先使用-const" class="headerlink" title="1. 优先使用 const"></a>1. 优先使用 const</h1><p><code>const</code> 在 JS 中不仅可以用于命名常量，且因为其内存地址不可变的性质，所以也常用于声明数组与对象。在编程中多使用 <code>const</code> 代替 <code>let</code> 和 <code>var</code>，可以在风格上向 immutable 靠拢，在编程思维上开始摒弃副作用带来的影响。更多的使用 <code>const</code> 虽然可能会使声明项增多，但是对于开发者来说，摒弃副作减少了心智负担的同时，让命名语义化将会使代码的质量大大提升。</p>
<p>而在 JS 中如果过多的使用 <code>let</code> 或者 <code>var</code> 声明变量，阅读者往往需要把注意力游离于代码上下文，反复阅读才能理解当前变量的值，并且变量还可能会被其他函数引用更改。所以，显而易见地，使用变量越多其理解的成本也就越高，而且还很难跟踪其具体的值。以下代码统计数组中每个元素的总和，使用 <code>const</code> 命名一个常量后，你将无法在 <code>forEach</code> 的每一次循环时改动它。转而使用 <code>reduce</code>，我们减少了变量 <code>let count</code>，增加了常量 <code>const count</code>。这样，在随后的代码的引用中就无需担心变量的状态。因为，我们知道，此时的 <code>count</code> 是一个数值常量，一旦赋值就不会变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  count += item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> count = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="2-使用函数表达式优于函数声明"><a href="#2-使用函数表达式优于函数声明" class="headerlink" title="2. 使用函数表达式优于函数声明"></a>2. 使用函数表达式优于函数声明</h1><p>我们配合上文所提到的 <code>const</code>，能够使用函数表达式来创建一个函数，更多的时候我们会与箭头函数搭配 <code>const func = () =&gt; &#123;&#125;</code>。 这种方式优于传统函数声明的地方在于：</p>
<ul>
<li>语义化指名函数是不可变的</li>
<li>函数表达式可以被看作赋值语句，更加简单易懂，且无法覆盖（常量不能被重新声明且重复赋值）</li>
<li>函数声明在代码解析阶段会被引擎提升，存在先使用后声明的情况。高可读可预测的代码应该先声明再使用</li>
<li>搭配箭头函数使用减轻对 <code>this</code> 的思维依赖</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> addOne = <span class="function">(<span class="params">value</span>) =&gt;</span> value + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="3-使用-return-减少分支"><a href="#3-使用-return-减少分支" class="headerlink" title="3. 使用 return 减少分支"></a>3. 使用 return 减少分支</h1><p>分支泛滥问题在 JS 代码中很是普遍，推荐在可能的代码块中使用 <code>return</code> 优先返回。这样可以有效的减少分支泛滥的问题，同时也能使代码逻辑更加的清晰可读，因为在同一时间能总是只能做一件事情。</p>
<p>我们还可以在必要时优先 <code>return</code> 较短的逻辑块，使代码更加美观。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">    <span class="comment">// server code</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// client code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">    <span class="comment">// server code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// client code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-不要过度优化"><a href="#4-不要过度优化" class="headerlink" title="4. 不要过度优化"></a>4. 不要过度优化</h1><p>如果你不是在编写类库、框架、底层代码等对性能要求极为苛刻的工程时，请务必过度以代码的可读性来换取代码的高效率。大多数的过度优化会让代码的可读性急剧下降，得不偿失！</p>
<ol>
<li>不必要的减少内存空间使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> fullname;</span><br><span class="line">users.forEach(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  fullname = user.firstname + user.lastname;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  register(fullname);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">users.forEach(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullName = user.firstname + user.lastname;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  register(fullname);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不必要的运算优化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> len = users.length;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">i = <span class="number">0</span>; i &lt; len; i++&gt;</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">users.forEach(<span class="function"><span class="params">user</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="5-减少魔术字符"><a href="#5-减少魔术字符" class="headerlink" title="5. 减少魔术字符"></a>5. 减少魔术字符</h1><p>魔术字符串指的是，在代码之中多次出现，与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除这些魔术字符，改由清晰的变量代替。</p>
<p>而通常，我们还会把所有的字符或数字统一声明在一个常量的文件内，如 <code>host</code> <code>defaultSettings</code> <code>port</code> 等等，这将会有益于后期维护工作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&quot;https://api.example.com&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;host&#125;</span>/1/users`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&quot;https://api.example.com&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> apiVersion = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> apis = &#123;</span><br><span class="line">  users: <span class="string">&quot;users&quot;</span>,</span><br><span class="line">  goods: <span class="string">&quot;goods&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;host&#125;</span>/<span class="subst">$&#123;apiVersion&#125;</span>/<span class="subst">$&#123;apis.users&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h1 id="6-函数不要有过多的参数"><a href="#6-函数不要有过多的参数" class="headerlink" title="6. 函数不要有过多的参数"></a>6. 函数不要有过多的参数</h1><p>在不断变动的需求中，我们编写的函数可能会有越来越多的参数。但要注意一点，当一个函数有较多的参数时，就会给调用方带来困扰。我们并非需要把每一个函数都实现 <strong>curry</strong>，但减少函数参数、合并参数、拆分函数功能都会让代码的可读性与拓展性更上一个台阶。</p>
<p>在调用较多参数的函数时，我们不仅要记住每个参数的位置，若有参数空缺时还需对其进行补位（如传入 <code>null</code> <code>undefined</code>），这会导致声明与调用的代码中都被迫存在非常多的冗余判断。所以在参数个数出现增长时，就可以考虑将其中的一部分合成一个参数对象，或是将函数内的功能进行拆分，作为一个新的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">id, name, telephone, email, address, createBy</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">id, userOptions</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="7-保持函数的专注"><a href="#7-保持函数的专注" class="headerlink" title="7. 保持函数的专注"></a>7. 保持函数的专注</h1><p>在一个函数里最好只做一件事，同时最好让函数的名字与做的这件事与之相关联，尤为重要！在单个函数中累积逻辑，会给阅读者带来非常大的心智负担，如果我们尝试函数拆分、组合并合理化命名，将会使代码整体获得极大的美感。使代码井井有条，泾渭分明也是一门别样的艺术。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> header = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> options = <span class="comment">// ...</span></span><br><span class="line">    options.header = headers;</span><br><span class="line">    <span class="keyword">const</span> host = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(id.length &gt; <span class="number">1</span>) <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> fetch(url, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> makeOptions = <span class="function">() =&gt;</span> &#123; <span class="comment">// ... &#125;;</span></span><br><span class="line"><span class="keyword">const</span> makeUrl = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="comment">// ... &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = makeOptions();</span><br><span class="line">    <span class="keyword">const</span> url = makeUrl(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fetch(url, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-使用语义化命名代替冗长的判断条件"><a href="#8-使用语义化命名代替冗长的判断条件" class="headerlink" title="8. 使用语义化命名代替冗长的判断条件"></a>8. 使用语义化命名代替冗长的判断条件</h1><p>过长的判断条件可能会在编写的当下烂熟于心，但常常会在一段时间回头再看觉得匪夷所思，很难理解其中的逻辑。所以，将其使用语义化的常量代替则可以向阅读者提示其含义，更是省下了不必要的注释，可真是一举两得！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为青少年</span></span><br><span class="line"><span class="keyword">if</span> (user.age &lt; <span class="number">19</span> &amp;&amp; user.age &gt; <span class="number">13</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> isTeenAgeMember = user.age &gt; <span class="number">13</span> &amp;&amp; user.age &lt; <span class="number">19</span>;</span><br><span class="line"><span class="keyword">if</span> (isTeenAgeMember) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-减少函数的副作用"><a href="#9-减少函数的副作用" class="headerlink" title="9. 减少函数的副作用"></a>9. 减少函数的副作用</h1><p>减少函数副作用一直以来都是 JS 社区中的长青话题，特别是 React 社区，而减少副作用并非总是需要以纯函数来解决所有问题。所以无需紧张，我们知道副作用会使得状态变化难以捕捉，在编程中应当以编写较少的副作用函数为目标，使函数的预期与实际保持一致的同时又不会造成过多的“噪音”。虽然，这或许会在构思和声明阶段花费一些时间，但对于整体代码的质量来说，是一件以小换大的好事！</p>
<p>你可能会发现有些时候不可避免的引用并改变了函数外部的状态，比如缓存某些值，为此你陷入了重构的苦恼。事实上不必过于忧虑，你想做的必然有其道理。这就是<strong>编程中取舍</strong>的问题，学会在编程、架构、工程上有所取舍（并不是随心所欲）后构建出的产品，自然会带有一定的特色。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> user = getUser();</span><br><span class="line"><span class="keyword">const</span> upload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  user.tempField = <span class="string">&quot;temp content&quot;</span>;</span><br><span class="line">  <span class="comment">// fetch user...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> user = getUser();</span><br><span class="line"><span class="keyword">const</span> upload = <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> tempUser = &#123; ...user, <span class="attr">tempField</span>: <span class="string">&quot;temp content&quot;</span> &#125;;</span><br><span class="line">  <span class="comment">// fetch user...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>更优雅的JavaScript 2</title>
    <url>/2020/01/15/more-elegant-javascript-2/</url>
    <content><![CDATA[<p>接着上一文，在<a href="/2019/12/13/more-elegant-javascript-1/">更优雅的 JavaScript 1</a>中，我们聊到了基础的 JavaScript 编写的建议。包括如何可靠的声明变量、常量、函数、以及利用合适的函数构建合适的逻辑，现在我们思考改善代码的第一步，如何命名？</p>
<p>在我们开始阅读代码之前，编码风格与命名方式会比代码的抽象方式、设计技巧更令我们印象深刻。很多时候也会为项目的整体风格定下基调。如果你阅读过一些算法工程师写的代码，常常会看到<em>单字母变量</em>、<em>反复的声明</em>，<em>不知所以的赋值与拷贝</em>、<em>累赘的条件判断</em>等等。我们虽不能说这样有问题，因为他们的代码大多的确是可以正常的运作，甚至在运行的时间或空间效率上有一些优势。但这在工程，特别是大型工程中是不值得称道的，根据经验我们可以把这类代码归类为“屎山”，充其量是“堆”了一摊高性能的“屎山”。</p>
<p>而我们现在做的则是脱离“编程只不过是工具”的阶段，脱离“屎山男孩”，让机器面有喜色、富有人性，使阅读者在某个瞬间也能切实的感受到创作者的思维跳动与审美哲学。</p>
<a id="more"></a>

<h1 id="1-富有准确性的命名"><a href="#1-富有准确性的命名" class="headerlink" title="1. 富有准确性的命名"></a>1. 富有准确性的命名</h1><p>事实上，你完全可以使用 <code>doSomeThing</code> 来命名所有的函数，毕竟它们真的只是提供某些微不足道的功能。但当你有了多个，甚至是成百上千个函数时，这将是一场灾难。这是一个浅显易懂的道理，即便是毫无经验的开发人员也会意识到命名爆炸的问题，他们隐约明白了什么是好的编程风格。但最后，甚至是大多数都止步于 <code>doSomeThing</code> 到“优美”之间的某一个站上。然后他们心里就默念，这就够了。</p>
<ol>
<li> 命名只需要有必要的词，除非有需求，否则不要堆砌</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> theBook = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> _book = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bookObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> theNewBook = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可读的条件判断</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> prefix = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> availableName = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> hasPrefixName = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可读的函数</li>
</ol>
<p>当我们要从网络上获取用户信息时，<code>getUser</code> 就不是一个准确的表达，<code>get</code> 太过于宽泛，它该表示是从数据库获取还是从网络获取？是以用户名获取还是用 ID 获取？这都有区别，现在我们可以先从命名的层面上思考它们的区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> fetchUserByName = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> findOneUserByID = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good(any environment, any params)</span></span><br><span class="line"><span class="keyword">const</span> getUsers = <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>准确的表达</li>
</ol>
<p>属性可以避免不必要的描述，言简意赅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  bookname: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  length: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  pages: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意单复数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> book = findBooks();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> books = findBooks();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>不必要的约定</li>
</ol>
<p>通常在示例或无意义的遍历中，我们会把每一个回调函数的参数写作 <code>item</code> <code>value</code> <code>element</code> 等等，这在一些场景中的确可以让阅读者忽略掉不必要的描述，从而专注于逻辑本身。但这并非总是合适，特别是我们需要表达状态的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> titles = books</span><br><span class="line">  .map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.title)</span><br><span class="line">  .filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.length &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> titles = books</span><br><span class="line">  .map(<span class="function">(<span class="params">book</span>) =&gt;</span> book.title)</span><br><span class="line">  .filter(<span class="function">(<span class="params">title</span>) =&gt;</span> title.length &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="2-观察与思考"><a href="#2-观察与思考" class="headerlink" title="2. 观察与思考"></a>2. 观察与思考</h1><p>观察是一个模糊的概念，可以尝试让同事朋友阅读你的代码，问问他们的感觉，哪些命名生硬，哪些词不达意，哪些又能让他们产生共鸣。一个可学习的方式就是在 <code>GitHub</code> 上阅读代码，你也能注意到开发者们的情绪波动，这里真的需要这些定义吗？这里有必要写的这么短小精悍吗？这里是不是写的太过于 <code>OC</code> 风了。试图从阅读代码理解开发者创作时的想法是很有趣的一件事件，这些情绪的波动还可能能让你明白他们大约处于编程、人生、情感的什么状态，有助于你深刻的理解接口与设计。</p>
<p>在一个项目中见到 <code>created</code> 时，便可以知道这调用发生在 <code>create</code> 之后，而非之前或者之中。以此类推便可以有 <code>destroyed</code> 或其他函数。如果项目是来自富有经验的开发者，这些细节会帮助你在代码中极快的理解作者的构思。</p>
<p>在阅读某些源码时，我们可能会注意到一些细节，就是一些旧有的功能被改变了，程序员只能被迫去修改这些已有的接口使之兼容。同时想要与原有的风格保持一些同步，有时也会衍生出一些新的接口，他们被置于一些结构体中，随着时间的推移可以推理，未来的一些接口也会被移入这些结构体 ———— 这就是我们对于命名的观察与思考。我曾经看见过有人说“狗是人类的朋友，taobao 的文档连狗都不如”，这就是他们观察的结果了，虽然好像令人不那么开心。</p>
<h1 id="3-巧妙与投机取巧"><a href="#3-巧妙与投机取巧" class="headerlink" title="3. 巧妙与投机取巧"></a>3. 巧妙与投机取巧</h1><p>我们可以断定<strong>巧妙</strong>是优雅命名中最重要的一部分，比如 <code>rvm</code> 与其他的一些命令行工具中的 uninstall 功能，其命令为 <code>implode</code> 。这好像有点意思，是吧？但事实上我见到的绝大多数的巧妙不过是“投机取巧”，他们苦心孤诣的作品是一大段没有说明的八进制、二进制代码，一堆三元堆砌的单行逻辑，一些谐音名字，以及不合时宜的正则表达式等等，这并不漂亮，这是歧路。</p>
<ol>
<li>自作聪明的谐音</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> markdowm2html = <span class="function">(<span class="params">template</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> markdownToHmtl = <span class="function">(<span class="params">template</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以语义化的正则</li>
</ol>
<p>代码并非是越简短越好，虽然多数场景下，我们需要尽可能的避免长篇累牍。但在必要时，可以使用命名和语义化的代码块来试图说明逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> isUser = <span class="regexp">/^name/</span>.test(user.name) &amp;&amp; <span class="regexp">/^http/</span>.test(user.url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> isUserName = user.name.starstWith(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isUrl = user.blog.startsWith(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isUser = isUserName &amp;&amp; isUrl;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>优美</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> hasDirOrCreateDir = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> ensureDir = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>粗解TCP的流量控制和拥塞控制</title>
    <url>/2019/06/30/tcp-traffic-and-congestion-control/</url>
    <content><![CDATA[<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="1-什么是流量控制"><a href="#1-什么是流量控制" class="headerlink" title="1. 什么是流量控制"></a>1. 什么是流量控制</h2><p>在 TCP 传输中，如果数据发送方的发送速度过快，那么就会造成数据接收方来不及接收所有发送出的数据。那么在这样的状况下，就会有分组丢失的情况发生。控制数据发送方的发送速度，使得数据接收方来得及接收，这就是流量控制。</p>
<h2 id="2-流量控制的目的"><a href="#2-流量控制的目的" class="headerlink" title="2. 流量控制的目的"></a>2. 流量控制的目的</h2><p>流量控制的其根本目的就是防止 TCP 传输中的分组丢失，它是构成 TCP 可靠性传输的其中一个方面。</p>
<h2 id="3-如何实现流量控制"><a href="#3-如何实现流量控制" class="headerlink" title="3. 如何实现流量控制"></a>3. 如何实现流量控制</h2><p>TCP 传输的流量控制由<strong>滑动窗口协议</strong>（<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82"><strong>连续 ARQ 协议</strong></a>）实现的，滑动窗口协议既能保证分组无差错、有序接收，也实现了流量控制的功能。主要的方式就是接收方在返回的 ACK 中会包含自己的接收窗口大小，并利用该接收窗口大小来实现控制发送方的数据发送。</p>
<a id="more"></a>

<hr>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="1-什么是拥塞控制"><a href="#1-什么是拥塞控制" class="headerlink" title="1. 什么是拥塞控制"></a>1. 什么是拥塞控制</h2><p>拥塞控制是一种用来调整 TCP 链接单次发送分组数量（<strong>单次发送量</strong>，通常叫 cwnd）的算法</p>
<h2 id="2-拥塞控制的目的"><a href="#2-拥塞控制的目的" class="headerlink" title="2. 拥塞控制的目的"></a>2. 拥塞控制的目的</h2><p>拥塞控制的其根本目的是防止通信子网中某一部分的分组数量过多，使得该部分的网络来不及处理，导致该通讯子网乃至整个网络性能下降的现象发生。严重的话还会导致网络通信业务陷入停顿，既出现死锁的现象。</p>
<p>其实就是类似于平时深圳公路网中常见的交通拥挤一样，当节假日出行的车辆大量增加时，各种走向的车流互相干扰。不仅如此，还有各路段不停修路，最终导致的堵车。</p>
<h2 id="3-如何实现拥塞控制"><a href="#3-如何实现拥塞控制" class="headerlink" title="3. 如何实现拥塞控制"></a>3. 如何实现拥塞控制</h2><p>在讲如何实现拥塞控制之前，需要介绍两个概念，第一个就是<strong>拥塞窗口 cwnd</strong>（<strong>congestion window</strong>），而第二个则是慢开始门限 <strong>ssthresh</strong>（<strong>slow start thresh</strong>）。<strong>后面的内容将会用 cwnd 和 ssthresh 代指它们两个</strong>，下面是对这两个概念的具体解释：</p>
<ol>
<li><p>发送方会维持一个拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且会根据实际情况动态变化。发送方让自己的发送窗口大小等于拥塞窗口大小，另外考虑到接收方的接受能力，发送方的发送窗口可能还需要小于拥塞窗口。</p>
</li>
<li><p>为了防止拥塞窗口增长过快，发送方还会维持一个慢开始门限变量，一旦到达慢开始门限的值后就会从慢开始算法转为执行拥塞避免算法。</p>
</li>
</ol>
<h3 id="1-慢开始算法"><a href="#1-慢开始算法" class="headerlink" title="1) 慢开始算法"></a>1) 慢开始算法</h3><p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是由小到大逐渐增加 cwnd 的大小。从下图可以看到，一个传输轮次所经历的时间其实就是往返时间 RTT，而且每经过一个传输轮次，cwnd 就加倍。所以慢开始里的“慢”并不是指 cwnd 增长的速率慢，而是指在 TCP 传输开始发送报文段时，初始设置的 cwnd 较小，然后再指数式增大。这当然会比，在初始就设置为较大的 cwnd 一下子把许多报文段注入到网络中要“慢的多”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201026180823.png" alt="慢开始算法"></p>
<p>为了防止慢开始算法，让 cwnd 走上无止境的指数式增长的道路，上面提到的 ssthresh 就起到了关键的作用。ssthresh 的具体作用如下，所以在这里可以看出慢开始算法和拥塞避免算法在拥塞控制中是相辅相成的：</p>
<ol>
<li>当 <strong>cwnd &lt; ssthresh</strong> 时，就执行慢开始算法；</li>
<li>当 <strong>cwnd &gt; ssthresh</strong> 时，就改为执行拥塞避免算法；</li>
<li>当 <strong>cwnd = ssthresh</strong> 时，慢开始与拥塞避免算法任选。</li>
</ol>
<h3 id="2-拥塞避免算法"><a href="#2-拥塞避免算法" class="headerlink" title="2) 拥塞避免算法"></a>2) 拥塞避免算法</h3><p>拥塞避免算法的思路就是让 cwnd 缓慢增长，即每经过一个往返时间 RTT 就把发送方的 cwnd +1，而不是指数式的加倍。这样有助于 cwnd 按线性规律的缓慢增长。另外无论是在慢开始算法阶段还是拥塞避免算法阶段，只要发送方判断网络出现拥塞（主要是根据有没有定时的收到接收方的确认，虽然没有收到确认可能是其他原因造成的。但是无法判断具体原因，所以都当做拥塞来进行处理），就把 ssthresh 设置为出现拥塞时的发送窗口大小的一半（但不能小于 2），然后把 cwnd 重新置为 1，然后改为执行慢开始算法（这样做的目的是要迅速减少发送方发送到网络中的分组数，使得拥塞的网络中的路由器有足够的时间把积压的分组处理完毕）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201026183338.png" alt="拥塞避免算法"></p>
<ol>
<li>cwnd 初始化为 1 个报文段，ssthresh 初始值为 16</li>
<li>开始执行慢开始算法，指数增长到第 4 轮，既 cwnd=ssthresh=16，然后改为执行拥塞避免算法，cwnd 按加法增长（线性规律增长）</li>
<li>假定 cwnd=24 时，网络出现超时（拥塞），则设置 ssthresh 为出现拥塞时的发送窗口大小的一半，既 ssthresh=12，cwnd 重新设置为 1，然后改为执行慢开始算法。当 cwnd=ssthresh=12 时，为避免拥塞，改为执行拥塞避免算法</li>
</ol>
<h3 id="2-快重传算法"><a href="#2-快重传算法" class="headerlink" title="2) 快重传算法"></a>2) 快重传算法</h3><p>快重传算法的思路就是要求接收方在收到 1 个失序的报文段后就立即发出重复确认（为的是让发送方及早知道有报文段没有到达）。快重传算法规定，发送方只要一连收到 3 个重复确认（确认丢失段的前一个段）就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201026185311.png" alt="快重传算法"></p>
<h3 id="4-快恢复算法"><a href="#4-快恢复算法" class="headerlink" title="4) 快恢复算法"></a>4) 快恢复算法</h3><p>快重传算法一般与快恢复算法配合使用，快恢复算法的思路就是当发送方连续收到 3 个重复确认时，就执行“乘法减少”算法，设置 ssthresh 为遇到突发情况时发送窗口大小的一半预防网络发生拥塞，考虑到如果网络出现了拥塞就不会接收到好几个重复确认，所以发送方认为现在网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 减半后的值，然后改为执行拥塞避免算法，使 cwnd 缓慢增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201026190649.png" alt="快恢复算法"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>流量控制主要作用于接收方，它是控制发送方的发送速度从而使接受方能够来的急接收发送方所发送的数据，防止分组丢失的控制方法。由<strong>滑动窗口协议</strong>（<strong>连续 ARQ 协议</strong>）实现，滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制的功能。<br>拥塞控制则作用于网络，它是防止过多的数据注入到传输的网络中，避免网络负载过大的情况发生。常用的控制方法如下：</p>
<ol>
<li>慢开始算法+拥塞避免算法</li>
<li>快重传算法+快恢复算法</li>
</ol>
<p>另外，慢开始算法只是在 TCP 传输建立时和网络出现超时时才使用。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>流量控制</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么TCP/IP要拆分我的数据</title>
    <url>/2019/05/31/why-tcp-ip-protocol-fragemented-my-packet/</url>
    <content><![CDATA[<p>TCP/IP 作为目前互联网举足轻重的网络通信协议，不是没有它的道理。TCP/IP 提供供了点对点的链接机制，以让源主机中的源进程发出的数据能够送达目标主机的目标进程里去，这其中的<strong>资料封装、寻址、传输、路由、接收</strong>都会以标准化的操作完成，并且它们还能保证数据在传输过程中<strong>有序</strong>、<strong>不重</strong>、<strong>不漏</strong>。</p>
<p>但是你不知道的是，当应用层协议使用传输层的 TCP 协议进行数据传输时，传输层 TCP 协议可能会将应用层所发送的消息分成多个数据段，我们一般称呼它叫：<strong>TCP 分段</strong>。而在其下层的网络层 IP 协议也有可能会对传输层 TCP 协议的数据段分成多个数据包，我们一般称呼它叫：<strong>IP 分片</strong>。但是由于 TCP 协议会自行先分段，所以正常情况下都轮不到 IP 协议进行分片。那为什么它们要拆分我们的数据呢？又为什么 TCP 协议自行分段后，就没 IP 协议什么事了呢？我们带着这些疑问继续探索。</p>
<a id="more"></a>

<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201031123646.png" alt="TCP分段IP分包"></p>
<p>在开始之前，我们先达成共识：</p>
<ol>
<li>协议层中传输数据的基本单位统称为：Data Unit（数据单元）</li>
<li>网络层 IP 协议传输的数据单元称为：Packet(包）</li>
<li>传输层 TCP 协议传输的数据单元称为：Segment（段）</li>
<li>传输层 UDP 协议传输的数据单元称为：Datagram（报）</li>
<li>应用层传输的数据单元称为：Message（消息）</li>
</ol>
<p>并且，我们把前提摘要先提前放出来：</p>
<ol>
<li>IP 协议会分片传输过大的数据包避免物理设备的限制</li>
<li>TCP 协议会分段传输过大的数据段保证整体的传输性能，同时避免遭到 IP 协议分片</li>
</ol>
<h1 id="最大传输单元和-IP-协议分片"><a href="#最大传输单元和-IP-协议分片" class="headerlink" title="最大传输单元和 IP 协议分片"></a>最大传输单元和 IP 协议分片</h1><p>IP 协议适用于传输数据包的协议，作为网络层协议，它能提供数据的<strong>路由</strong>和<strong>寻址</strong>功能，让数据能通过网络到达目的地。但是由于现实中物理设备的限制，导致传输于网络中的数据包不能太大，所以在不同设备进行数据传输前，需要先确定一个 IP 数据包的大小上限，<strong>既最大传输单元</strong>（MTU）,MTU 是 IP 数据包能够传输的数据大小上限。</p>
<p>MTU 的值不是越大越好，更大的 MTU 意味着更低的额外开销，但会增加丢包所带来的风险。更小的 MTU 意味着更低的网络延迟，但太小又会让额外开销加大。所以有一个合适 MTU 值对于网络传输来说是非常重要的，每一个物理设备都自己的 MTU，两个主机之间的 MTU 依赖其底层的网络能力，它由整个链路上 MTU 最小的那台物理设备所决定。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201031133126.png" alt="链路MTU发现"></p>
<p><strong>路径最大传输单元发现</strong>（Path MTU Discovery，PMTUD）是用来确定两个主机数据传输 MTU 的机制，它的工作原理如下：</p>
<ol>
<li>向目标主机发送数据包头 DF 控制位设置为 1 的 IP 数据包 ，DF 是不分片（Don’t Fragment）的缩写</li>
<li>路径上的物理设备会根据数据包的大小和自己的 MTU 比较，做出不同的决定：<ol>
<li>如果数据包的大小大于设备的 MTU，就会丢弃数据包并发回一个包含该设备 MTU 的 ICMP 的消息</li>
<li>如果数据包小于设备的 MTU，就会继续向目标主机传递数据包</li>
</ol>
</li>
<li>源主机收到 ICMP 消息后，会不断使用新的 MTU 发送 IP 数据包，直到 IP 数据包到达目标主机</li>
</ol>
<blockquote>
<p>ICMP 是互联网控制协议（Internet Control Message Protocol），它能在 IP 主机之间传递控制消息</p>
</blockquote>
<p>位于第二层的以太网协议对其<strong>数据帧的数据栏位</strong>限制一般都是 1500 字节，所以在一般情况下，IP 主机的路径 MTU 都是 1500，扣除 IP 协议数据包头部占用的 20 字节，则如果数据包内的数据大于 1480 字节，那么 IP 协议就开始拆分我们的数据，把数据分到多个数据包中分片传输。</p>
<p>IP 协议的数据包分片对于传输层协议是透明的，假设我们使用 UDP 协议传输 2000 字节的数据，加上 UDP 协议报头占用的 8 字节，则 IP 协议需要传输 2008 字节的数据。但是当 IP 协议发现自己的路径 MTU 是 1480 字节时，它察觉到其要传输的数据 2008 字节大于 MTU 的 1480 字节，就会手起刀落对 UDP 的数据报进行拆分。如下图所示：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201031141508.png" alt="IP协议对UDP数据报进行分片"></p>
<p>具体分片后的情况如下：</p>
<ol>
<li>20 字节 IP 协议数据包头 + 8 字节 UDP 协议数据报头 + 1472 字节数据</li>
<li>20 字节 IP 协议数据包头 + 528 字节数据</li>
</ol>
<p>目标主机在接收到数据包时会对分片的数据进行重组，不过因为第二个数据包中不包含 UDP 协议的相关信息，一旦发生丢包，那整个 UDP 数据报就无法重新组合。如果 UDP 数据报需要传输的数据过多，那么 IP 协议就会抄起家伙大量分片，增加了数据传输的不稳定性。如果 IP 协议没有数据包大小的限制，那么上层可以以消息为单位传输数据，自然就不存在分片和组合的需求，不过因为物理设备 MTU 的限制，想要保证数据传输的可靠性和稳定性还是需要传输层的配合。</p>
<h1 id="IP-协议分片与-TCP-最大分段大小"><a href="#IP-协议分片与-TCP-最大分段大小" class="headerlink" title="IP 协议分片与 TCP 最大分段大小"></a>IP 协议分片与 TCP 最大分段大小</h1><p>TCP 协议是面向字节流的协议，应用层交给 TCP 协议的数据并不会以消息为单位往目标主机发送，并且 TCP 协议引入了最大分段大小（Maximum segment size，MSS）这一概念，它是 TCP 数据段能够携带的数据上限。在正常情况下，TCP 链接的 MSS 是 MTU - 40 字节（IP 和 TCP 协议头部各占用 20 字节），既 1460 字节；不过如果通信双方没有指定 MSS 的话，在默认情况下 MSS 的大小是 536 字节。所以应用层交给 TCP 协议发送的数据大小如果大于 MSS 就可能会被拆分到多个数据段里。</p>
<p>IP 协议的 MTU 是物理设备上的限制，它限制了传输路径上能够发送数据包大小的上限。而 TCP 协议的 MSS 是操作系统内核层面的限制，通信双方会在三次握手时确定这次所建立连接的 MSS 值。一旦确定了 MSS，TCP 协议就会对应用层交给 TCP 协议发送的数据按 MSS 的大小进行拆分，构成多个数据段。而需要注意的是，IP 协议和 TCP 协议虽然都会对数据进行拆分，但是 IP 协议以数据包为单位组织数据，而 TCP 协议以数据段为单位组织数据。这一点在文章开始的达成共识时有提到过。</p>
<p>如下图所示，如果 TCP 连接 MSS 是 1460 字节，应用层想通过 TCP 协议传输 2000 字节的消息数据，那么 TCP 协议会根据 MSS 将 2000 字节的数据拆分到两个数据段中：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201031154702.png" alt="TCP协议数据段进行分段"></p>
<p>最终分段后的情况如下：</p>
<ol>
<li>20 字节 IP 协议数据包头 + 20 字节 TCP 协议数据段头 + 1460 字节消息数据</li>
<li>20 字节 IP 协议数据包头 + 20 字节 TCP 协议数据段头 + 540 字节消息数据</li>
</ol>
<p>从应用层的角度来看，两个数据段中的 2000 字节数据构成了源主机想要发送的消息，但是 TCP 协议是面向字节流的，向协议写入的数据会以流的形式传递到对端。TCP 协议为了保证可靠性，会通过 IP 协议的 MTU 计算出 MSS 并根据 MSS 大小进行分段，以至于能够避免 IP 协议对装有数据段的数据包进行分片。因为 IP 协议对数据包的分片对于上层来说是透明的，如果上层协议不针对 MTU 做一些大小限制，那么 IP 协议进行分片操作时，将导致部分数据包里的部分数据与包含传输层的协议头的数据包分离，一旦数据包发生丢失就只能丢弃全部数据。损失惨重！</p>
<p>我们可以通过一个例子分析 MSS 存在的必要性。如下图所示，假设 TCP 协议中不存在 MSS 的概念，因为每个数据段的大小没有上限，当 TCP 协议交给 IP 协议各发送两个共 1600 字节的 IP 协议数据包时，由于物理设备的限制，IP 协议的路径 MTU 为 1500，所以 IP 协议会对数据包进行分片：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201031164352.png" alt="IP协议第TCP协议数据段进行分片"></p>
<p>所以就会造成不存在 TCP 协议头的数据包，那么当 IP 协议进行数据传输时出现了丢包，TCP 协议的接收方就没办法对数据段进行重组，最终导致整个 TCP 数据段都需要重传，带来了更多的额外开销。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>TCP/IP 拆分数据究根结底就是因为物理设备的限制：</p>
<ol>
<li>IP 协议则是因为数据包大于 MTU 后会被链路中的设备丢弃，为了避免被丢弃，IP 协议就需要通过路径 MTU 发现获取链路上的 MTU 值后，再抄起数据包分片大刀，把数据包大小大于 MTU 的一节一节砍断并把砍断的数据包重新封包发送。</li>
<li>而 TCP 协议则是为了避免自个的数据段被 IP 协议的分片大刀无情砍中，因为一旦砍中，那么就会首尾分离，就需要目标主机进行重组，产生不必要的性能消耗，万一传输途中还丢包了，就会前功尽弃需要全部重传。所以根据这个情况 TCP 协议自然的也就自觉的按造 MTU 算出自己的 MSS，然后再根据 MSS 学起 IP 协议抄起了分段大刀，利落的砍向了应用层传过来的待发送消息数据，并重新封段，拿给 IP 协议发送。</li>
</ol>
<h1 id="延伸阅读"><a href="#延伸阅读" class="headerlink" title="延伸阅读"></a>延伸阅读</h1><ul>
<li><a href="/2019/04/04/why-tcp-sticky-my-packet/">为什么 TCP 要粘我的数据包</a></li>
</ul>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>数据包</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么TCP要粘我的数据包</title>
    <url>/2019/04/04/why-tcp-sticky-my-packet/</url>
    <content><![CDATA[<p>其实 TCP 粘包这个问题，在 TCP 的设计角度上看，其问题本质就是一个伪命题。但是为什么会有那么多的开发者提出这样的问题？我们从 TCP 设计的特性可以不难看出，TCP 本就是<strong>面向连接</strong>、<strong>基于字节流</strong>且<strong>可靠</strong>的传输层通信协议，所以在 TCP 的这个层面来说并不存在包的这个概念，也就没有粘包这么一说了。那按照这么说，粘包问题还能凭空出现的？</p>
<p>在开始之前，我们先达成共识：</p>
<ol>
<li>协议层中传输数据的基本单位统称为：Data Unit（数据单元）</li>
<li>网络层 IP 协议传输的数据单元称为：Packet(包）</li>
<li>传输层 TCP 协议传输的数据单元称为：Segment（段）</li>
<li>传输层 UDP 协议传输的数据单元称为：Datagram（报）</li>
<li>应用层传输的数据单元称为：Message（消息）</li>
</ol>
<a id="more"></a>

<h1 id="序章"><a href="#序章" class="headerlink" title="序章"></a>序章</h1><p>IP 协议在网络层解决了数据包的路由和传输问题，得以让基于其上层的传输层 TCP 协议不用再去关注路由和寻址，那么 TCP 就把这部分的注意力集中到了解决数据传输中的<strong>有序性</strong>和<strong>可靠性</strong>问题去了，以至于可以让其上一层协议不必担心所托付的数据能否排排坐的传输到接收方。只要被写入 TCP 协议缓冲区中的数据，协议栈几乎都能保证其数据的送达。</p>
<p>当应用层协议使用 TCP 协议进行数据传输时，TCP 协议可能会将应用层协议所发送的消息<strong>重新分割组合到多个数据段</strong>中并以字节流的形式依次发送。那么这样一个 TCP 的数据段可能就不会按应用层发送的消息一一对应上。而数据接收方收到的某个数据段就可能会由<em>多个应用层消息</em>组成，应用层从 TCP 接收缓冲区读取数据时就会发现粘连的消息，这时就需要对这些粘连的消息按消息边界规则进行拆分。那么总结下来，就是以下两点：</p>
<ol>
<li>TCP 协议是<strong>面向字节流</strong>的协议，它可能会<strong>重新分割组合</strong>应用层协议的消息到多个数据段中</li>
<li>应用层协议<strong>没有定义消息的边界</strong>，导致数据的接收方<strong>无法按边界拆分粘连的消息</strong></li>
</ol>
<h1 id="面向字节流"><a href="#面向字节流" class="headerlink" title="面向字节流"></a>面向字节流</h1><p>应用层交给 TCP 协议的数据并不会以包为单位向目标主机传输，这些数据在某些情况下会被组合成一个数据段发送给目标主机。Nagle 算法是一种采用通过减少发送有效数据含量少的 TCP 数据段手段，以提升 TCP 传输性能的算法。因为网络宽带有限，它不会将数据含量很少的数据段直接发送到目标主机，而是会在 TCP 发送缓冲区中等待更多的待发送数据，这种延迟等待并批量发送数据的策略虽然会影响实时性，但是能够降低网络拥堵的可能性并减少额外开销。</p>
<p>在早期的互联网中，Telnet 是被广泛使用的应用程序，然而因为当时 Telnet 会产生大量只有 1 字节有效数据量的数据段，而这些数据段中都会存在包含 40 字节的协议描述信息。这带来的额外开销是很不乐观的，宽带的利用率只有仅仅的 2.44%，Nagle 算法就是在当时的这种使用场景下设计出来的。</p>
<p>当应用层协议通过 TCP 协议传输数据时，实际上待发的数据先被写入了 TCP 协议的发送缓冲区中，如果用户开启了 Nagle 算法，那么 TCP 协议可能不会立刻发送写入的数据，而是会等待缓冲区中的数据超过了最大数据段大小（MSS）或者上一个数据段被 ACK 时才会发送缓冲区中的数据。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201030172902.png" alt="Nagle算法重新分割组合应用层协议消息"></p>
<p>Nagle 算法确实能够在有效数据较少时提高网络宽带的利用率减少 TCP 和 IP 协议描述信息所带来的额外开销，但是使用该算法也可能会导致应用层协议多次写入的数据被重新分割组合发送，当接收方从 TCP 协议栈中读取数据时就会发现不相关的数据出现在同一个数据段中，应用层可能也没有定义消息的边界，造成没有办法对他们进行拆分。</p>
<p>除了 Nagle 算法之外，TCP 协议中还有另一个用于延迟发送数据的选项 TCP_CORK，如果我们开启了该选项，那么发送的数据小于最大数据段大小时，TCP 协议就会延迟 200ms 发送该数据或者等待缓冲区中的数据超过最大数据段大小。</p>
<p>无论是 TCP_NODELAY 还是 TCP_CORK，他们都会通过延迟发送数据来提高宽带的利用率，他们会对应用层协议写入的数据进行重新分割组合，而这些机制和配合能够出现的最重要的原因是 — TCP 协议是基础字节流的协议，其本身没有数据包的概念，不会按照数据包的机制去发送数据。</p>
<h1 id="消息边界"><a href="#消息边界" class="headerlink" title="消息边界"></a>消息边界</h1><p>如果我们系统性地学习过 TCP 协议，那么设计一个基于 TCP 协议且能够被 TCP 协议任意分割组装消息的应用层协议就不会有太大的问题。既然 TCP 协议是基于字节流的，这其实就意味着应用层协议需要自己划分消息的边界。</p>
<p>如果我们能在应用层协议中定义消息的边界，那么无论 TCP 协议如何对应用层协议的消息进行重新分割组装，那么接收方都能根据约定的消息划分规则来恢复被重新分割组装后的消息。在应用层协议中，最常见的两种边界划分规则就是：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201030195935.png" alt="应用程协议消息边界划分规则"></p>
<ol>
<li>基于长度</li>
<li>基础终结符（Delimiter）</li>
</ol>
<p>基于长度的实现有两种方式，固定长度将把应用层的消息都使用统一的大小，但这种固定长度的方式，当有效数据量小于该固定长度时就可能会出现资源浪费的情况。另外一种就是使用不固定长度，而这种方式需要在应用协议的协议头中增加表示数据负载的字段，这样接收方才可以从字节流中分离出不同的消息，HTTP 协议的消息边界就是基于长度实现的：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">HTTP&#x2F;1.1 200 OK</span><br><span class="line">Content-Type: text&#x2F;html; charset&#x3D;UFT-8</span><br><span class="line">Content-Length: 150</span><br><span class="line">...</span><br><span class="line">Connection: close</span><br></pre></td></tr></table></figure>

<figure class="highlight html"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>example<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello World<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>

<p>在上述 HTTP 消息中，我们使用 <code>Content-Length</code> 头表示 HTTP 消息的数据负载大小，当应用层协议解析到足够多的字节数后，就能从中分离出完整的 HTTP 消息，无论发送方如何处理对应的消息，我们都可以遵循这一规则完成 HTTP 消息的恢复工作。</p>
<p>不过 HTTP 协议除了使用基于长度的方式实现边界划分，当发送的内容大小不确定时，也会使用基于终结符的策略，并使用块传输（Chunked Transfer）的机制。此时 HTTP 头中就不再包含 <code>Content-Length</code> 了，它会转而使用负载大小为 0 的 HTTP 消息作为终结符表示消息边界。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>可以这么说，TCP 粘包问题是因为应用层协议开发者的错误设计导致的，他们忽略了 TCP 协议数据传输的核心机制 — 基于字节流，其本身并不存在数据包的概念。所有在 TCP 中传输的数据都是以流的形式进行传输，所以这就需要应用层协议开发者行设计消息的边界划分规则。所以粘包总的来说还是以下两点：</p>
<ol>
<li>TCP 协议是<strong>面向字节流</strong>的协议，它可能会<strong>重新分割组合</strong>应用层协议的消息到多个数据段中</li>
<li>应用层协议<strong>没有定义消息的边界</strong>，导致数据的接收方<strong>无法按边界拆分粘连的消息</strong></li>
</ol>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>数据包</tag>
        <tag>粘包</tag>
      </tags>
  </entry>
</search>
