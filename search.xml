<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>如何修改Git Commit的描述</title>
    <url>/2018/10/30/amend-git-committed-comment/</url>
    <content><![CDATA[<p>使用 Git 进行项目的版本管理，的确是能让项目代码更加的受控。但是如果能有清晰的 commit 记录以及描述，那将更是会锦上添花。在需求正常开发完后，有时难免会过于兴奋手滑敲错 commit 的描述。但如果对于不经常手滑的同学来说，可能还没研究过如何修改 commit 的描述。所以今天，我就想通过这一篇文章简单的记录一下 commit 描述的修改过程，顺便给自己留作回顾的作用。</p>
<p>修改 commit 描述分为以下两种情况，但这两种情况步骤基本相同，只是第二种需要在最后多加一步操作：</p>
<ol>
<li>还未将代码 push 到远程仓库</li>
<li>已将代码 push 到远程仓库</li>
</ol>
<a id="more"></a>

<h1 id="修改最后一次-commit-的描述"><a href="#修改最后一次-commit-的描述" class="headerlink" title="修改最后一次 commit 的描述"></a>修改最后一次 commit 的描述</h1><p>如果只是想修改最后一次 commit 后的描述，可以直接在命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>输入完后，会出现以下界面（commit 的描述位于界面的第一行）：</p>
<ol>
<li>按 <kbd>i</kbd> 键进入命令行的修改模式，修改位于界面第一行的 commit 描述</li>
<li>修改完后，按 <kbd>Esc</kbd> 键退出命令行的编辑模式</li>
<li>再输入 <code>:wq</code> 保存并退出，至此 commit 的描述就修改成功啦！</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201028225408.png" alt="修改最后一次commit的描述"></p>
<h1 id="修改之前某次-commit-的描述"><a href="#修改之前某次-commit-的描述" class="headerlink" title="修改之前某次 commit 的描述"></a>修改之前某次 commit 的描述</h1><p>如果是想修改之前某次 commit 的描述，则需要比修改最后一次 commit 的描述多上那么几个步骤。其实这个修改的原理，按我的理解就是先把版本回退到你想修改的某个版本，然后再修改当前回退到的版本的 commit 描述，修改完后再回到回退前的最新版本中。那么来吧！</p>
<p>首先在命令行输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 命令中最后的数字2指的是显示倒数第几次的commit，比如我这里的2就代表显示倒数第二次的commit描述</span></span><br><span class="line">git rebase -i HEAD~2</span><br></pre></td></tr></table></figure>

<p>输入完后，会出现以下界面（倒数几次的 commit 的描述都位于界面顶部）：</p>
<ol>
<li>想修改哪条 commit 的描述，就把该条 commit 描述前的 <strong>pick</strong> 改成 <strong>edit</strong>（修改的方式同上）</li>
<li>修改完后按 <kbd>Esc</kbd> 键退出命令行的编辑模式，</li>
<li>输入 <code>:wq</code> 保存并退出。</li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201028233014.png" alt="修改之前某次commit的描述1"></p>
<p>保存并退出后，会出现以下界面：</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201028234716.png" alt="修改之前某次commit的描述2"></p>
<p>然后，再往命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git commit --amend</span><br></pre></td></tr></table></figure>

<p>输入完后，就如同上面那样修改完描述，然后保存并退出后，再往命令行中输入以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git rebase --<span class="built_in">continue</span></span><br></pre></td></tr></table></figure>

<h1 id="修改之前的某几次-commit-的描述"><a href="#修改之前的某几次-commit-的描述" class="headerlink" title="修改之前的某几次 commit 的描述"></a>修改之前的某几次 commit 的描述</h1><p>修改之前某几次其实和上面修改某次的步骤差不多，不同之处在于以下几点：</p>
<ol>
<li>上面，第一个步骤中的命令，数字需要修改</li>
<li>然后在修改 <strong>pick</strong> 为 <strong>edit</strong> 的那一个步骤时，修改多个</li>
<li>最后依次修改描述（顺序是从旧到新），命令行中基本都会提示你接下来的操作是什么，每次修改一个注释都需要重复上面的最后两个步骤，直至修改完你所标记为 <strong>edit</strong> 的所有描述为止</li>
</ol>
<h1 id="已经将代码-push-到远程仓库"><a href="#已经将代码-push-到远程仓库" class="headerlink" title="已经将代码 push 到远程仓库"></a>已经将代码 push 到远程仓库</h1><p>在已经把代码 push 到远程仓库的情况下，还想修改 commit 的描述的话，在修改前首先需要从远程仓库 pull 最新的版本到本地仓库，确保两边的版本都是一致的状态。然后再按照情况，选择上面的几种方法来进行修改。最后，修改完需要再强制把本地仓库的版本 push 回远程仓库中。<strong>但很重要的一点是，在进行强制 push 之前，需要再三确认没有人往远程仓库提交更新的版本，否则远程仓库中更新的版本将会被你的版本所覆盖。</strong></p>
<p>在命令行中输入以下命令，强制 push 本地仓库版本到远程仓库中：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git push --force origin master</span><br></pre></td></tr></table></figure>

<p>大功告成！</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本管理</tag>
      </tags>
  </entry>
  <entry>
    <title>CommonJS Module和ES6 Modules之间的引用与转换</title>
    <url>/2019/10/05/commonjs-and-es6-modules/</url>
    <content><![CDATA[<p>平时在项目开发的过程中，因为 JavaScript 模块化的历史遗留问题，难免会存在在 CommonJS 的模块里头 <code>import</code> ES6 的模块，或者在 CommonJS 的模块里头 <code>require</code> ES6 的模块的情况发生。为了能够搞清楚他们之间的转换小秘密，所以就专门记录一下，方便日后回顾，顺便上来水一文。</p>
<blockquote>
<p>因为这两种模块在网络上存在着各式各样的叫法，所以在文章开始前，为了能够和大家达成一致的共识。在后面我将会用 <strong>CJS</strong> 代指 CommonJS Module，用 <strong>ESM</strong> 代指 ES Modules。</p>
</blockquote>
<h1 id="ESM-转-CJS"><a href="#ESM-转-CJS" class="headerlink" title="ESM 转 CJS"></a>ESM 转 CJS</h1><h2 id="1-ESM-export-转-CJS-exports"><a href="#1-ESM-export-转-CJS-exports" class="headerlink" title="1. ESM export 转 CJS exports"></a>1. ESM export 转 CJS exports</h2><p>举个栗子：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// a.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">var</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p><code>a.js</code> 中的 <strong>ESM</strong> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<blockquote>
<p>注：在 ESM 被转为 CJS 时，转译器会在其导出的对象中定义一个值为 <code>true</code> 的私有的变量 <code>__esModule</code></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.func = func;</span><br><span class="line"><span class="keyword">var</span> foo = (<span class="built_in">exports</span>.foo = <span class="string">&quot;bar&quot;</span>);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="built_in">exports</span>.default = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<p>其实也就等价于：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.__esModule = <span class="literal">true</span>; <span class="comment">// 该属性实际上会通过Object.defineProperty API设置为不可枚举</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">exports</span>.foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="built_in">exports</span>.func = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line"><span class="built_in">exports</span>.default = <span class="number">1</span>;</span><br></pre></td></tr></table></figure>
<a id="more"></a>

<h2 id="2-ESM-import-转-CJS-require"><a href="#2-ESM-import-转-CJS-require" class="headerlink" title="2. ESM import 转 CJS require"></a>2. ESM import 转 CJS require</h2><h3 id="2-1-Default-import"><a href="#2-1-Default-import" class="headerlink" title="2.1 Default import"></a>2.1 Default import</h3><p>还是一个栗子，直接默认导入 <code>a.js</code> 中的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">//  b.js</span></span><br><span class="line"><span class="keyword">import</span> a <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p><code>b.js</code> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> _a2 = _interopRequireDefault(_a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireDefault</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// 如果是ESM则直接返回obj，否则返回带有default属性的新对象</span></span><br><span class="line">  <span class="keyword">return</span> obj &amp;&amp; obj.__esModule ? obj : &#123; <span class="attr">default</span>: obj &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(_a2.default);</span><br></pre></td></tr></table></figure>

<h3 id="2-2-Wildcard-import"><a href="#2-2-Wildcard-import" class="headerlink" title="2.2 Wildcard import"></a>2.2 Wildcard import</h3><p>再一个栗子，名字空间导入 <code>a.js</code> 中的模块：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// b.js</span></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> a <span class="keyword">from</span> <span class="string">&quot;./a&quot;</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(a);</span><br></pre></td></tr></table></figure>

<p><code>b.js</code> 在经过 <strong>babel</strong> 转为 <strong>CJS</strong> 后，代码变为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="meta">&quot;use strict&quot;</span>;</span><br><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">exports</span>, <span class="string">&quot;__esModule&quot;</span>, &#123; <span class="attr">value</span>: <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> _a = <span class="built_in">require</span>(<span class="string">&quot;./a&quot;</span>);</span><br><span class="line"><span class="keyword">var</span> A = _interopRequireWildcard(_a);</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">_interopRequireWildcard</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ESM直接返回obj</span></span><br><span class="line">  <span class="keyword">if</span> (obj &amp;&amp; obj.__esModule) &#123;</span><br><span class="line">    <span class="keyword">return</span> obj;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// CJS的话就创建一个新的空对象，并把obj内的所有自有属性都浅复制到新对象中，最后再把obj赋值给新对象的default属性</span></span><br><span class="line">    <span class="keyword">var</span> newObj = &#123;&#125;;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">var</span> key <span class="keyword">in</span> obj) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">Object</span>.prototype.hasOwnProperty.call(obj, key)) &#123;</span><br><span class="line">          newObj[key] = obj[key];</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    newObj.default = obj;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> newObj;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h2><ol>
<li>ESM 的 <code>export</code> 相当于往 CJS 的 <code>exports</code> 上添加属性<ol>
<li><code>export var/let/const/function/class...</code> 会往 <code>exports</code> 上添加同名属性</li>
<li><code>export default</code> 会往 <code>exports</code> 上添加 default 属性</li>
</ol>
</li>
<li>ESM 可以 <strong>default</strong> <code>import</code> 和 <strong>wildcard</strong> <code>import</code> CJS<ol>
<li><strong>default</strong> <code>import</code> CJS 时，会创建一个新的空对象，并把 CJS 的导出对象 <code>exports</code> 赋值到新对象的 default 属性</li>
<li><strong>wildcard</strong> <code>import</code> CJS 时，会创建一个新的空对象，并把 CJS 的导出对象 <code>exports</code> 中的自有属性浅复制到新的空对象中，最后再把导出对象 <code>exports</code> 赋值到新对象的 default 属性</li>
</ol>
</li>
</ol>
<h1 id="ESM-中引用-CJS"><a href="#ESM-中引用-CJS" class="headerlink" title="ESM 中引用 CJS"></a>ESM 中引用 CJS</h1><p>根据上面得出的结论，ESM 中引用 CJS 有两种方式，栗子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="built_in">module</span>.export = &#123;</span><br><span class="line">  <span class="keyword">default</span>: <span class="string">&quot;myDefault&quot;</span>,</span><br><span class="line">  foo: <span class="string">&quot;bar&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// esm.js</span></span><br><span class="line"><span class="keyword">import</span> cjs <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs = (&#123; default: exports &#125;).default;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> * <span class="keyword">as</span> cjs2 <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs2 = (&#123; ...exports, default: exports &#125;)</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> &#123; <span class="keyword">default</span> <span class="keyword">as</span> cjs3 &#125; <span class="keyword">from</span> <span class="string">&quot;./cjs&quot;</span>;</span><br><span class="line"><span class="comment">// 相当于const cjs3 = (&#123; default: exports &#125;).default</span></span><br></pre></td></tr></table></figure>

<h1 id="CJS-中引用-ESM"><a href="#CJS-中引用-ESM" class="headerlink" title="CJS 中引用 ESM"></a>CJS 中引用 ESM</h1><p>在 CJS 中引用 ESM 相当于直接引用 ESM 转成 CJS 的 <code>module.exports</code>，栗子如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// es.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">let</span> foo = <span class="string">&quot;bar&quot;</span>;</span><br><span class="line"><span class="keyword">export</span> &#123; foo <span class="keyword">as</span> bar &#125;;</span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">cls</span> </span>&#123;&#125;</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// cjs.js</span></span><br><span class="line"><span class="keyword">var</span> es = <span class="built_in">require</span>(<span class="string">&quot;./es&quot;</span>);</span><br><span class="line"><span class="comment">/* es结构如下：</span></span><br><span class="line"><span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    foo,</span></span><br><span class="line"><span class="comment">    bar: foo,</span></span><br><span class="line"><span class="comment">    func,</span></span><br><span class="line"><span class="comment">    cls,</span></span><br><span class="line"><span class="comment">    default: 1</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JacaScript</tag>
        <tag>ESModules</tag>
        <tag>CommonJS</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2019/12/31/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
  </entry>
  <entry>
    <title>更优雅的JavaScript 1</title>
    <url>/2019/12/13/more-elegant-javascript-1/</url>
    <content><![CDATA[<p>貌似，现在大家写代码都只是在追求其极致性能、精巧体积、华丽技巧，而忽视了最重要的”<strong>code for hunmans</strong>“。</p>
<p>我们知道在日常项目开发时，代码被人阅读的难度是远高于执行引擎的。所以要写出好的代码就需要尝试脱离自己的视角，以第三人的眼光重新审视、理解其上下文的含义。 这样创作出的代码结构、组合、技巧才会予人阅读的幸福感。我们致力于书写优秀的代码就意味着，代码不仅仅是一个工具，更是将其视作为用来传达精神、思想、理念的一座桥梁。这是一种对于书写者智慧的锤炼与分享。</p>
<a id="more"></a>

<h1 id="1-优先使用-const"><a href="#1-优先使用-const" class="headerlink" title="1. 优先使用 const"></a>1. 优先使用 const</h1><p><code>const</code> 在 JS 中不仅可以用于命名常量，且因为其内存地址不可变的性质，所以也常用于声明数组与对象。在编程中多使用 <code>const</code> 代替 <code>let</code> 和 <code>var</code>，可以在风格上向 immutable 靠拢，在编程思维上开始摒弃副作用带来的影响。更多的使用 <code>const</code> 虽然可能会使声明项增多，但是对于开发者来说，摒弃副作减少了心智负担的同时，让命名语义化将会使代码的质量大大提升。</p>
<p>而在 JS 中如果过多的使用 <code>let</code> 或者 <code>var</code> 声明变量，阅读者往往需要把注意力游离于代码上下文，反复阅读才能理解当前变量的值，并且变量还可能会被其他函数引用更改。所以，显而易见地，使用变量越多其理解的成本也就越高，而且还很难跟踪其具体的值。以下代码统计数组中每个元素的总和，使用 <code>const</code> 命名一个常量后，你将无法在 <code>forEach</code> 的每一次循环时改动它。转而使用 <code>reduce</code>，我们减少了变量 <code>let count</code>，增加了常量 <code>const count</code>。这样，在随后的代码的引用中就无需担心变量的状态。因为，我们知道，此时的 <code>count</code> 是一个数值常量，一旦赋值就不会变化。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> count = <span class="number">0</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].forEach(<span class="function">(<span class="params">item</span>) =&gt;</span> &#123;</span><br><span class="line">  count += item;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> count = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].reduce(<span class="function">(<span class="params">pre, cur</span>) =&gt;</span> pre + cur, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="2-使用函数表达式优于函数声明"><a href="#2-使用函数表达式优于函数声明" class="headerlink" title="2. 使用函数表达式优于函数声明"></a>2. 使用函数表达式优于函数声明</h1><p>我们配合上文所提到的 <code>const</code>，能够使用函数表达式来创建一个函数，更多的时候我们会与箭头函数搭配 <code>const func = () =&gt; &#123;&#125;</code>。 这种方式优于传统函数声明的地方在于：</p>
<ul>
<li>语义化指名函数是不可变的</li>
<li>函数表达式可以被看作赋值语句，更加简单易懂，且无法覆盖（常量不能被重新声明且重复赋值）</li>
<li>函数声明在代码解析阶段会被引擎提升，存在先使用后声明的情况。高可读可预测的代码应该先声明再使用</li>
<li>搭配箭头函数使用减轻对 <code>this</code> 的思维依赖</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> value + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> addOne = <span class="function">(<span class="params">value</span>) =&gt;</span> value + <span class="number">1</span>;</span><br></pre></td></tr></table></figure>

<h1 id="3-使用-return-减少分支"><a href="#3-使用-return-减少分支" class="headerlink" title="3. 使用 return 减少分支"></a>3. 使用 return 减少分支</h1><p>分支泛滥问题在 JS 代码中很是普遍，推荐在可能的代码块中使用 <code>return</code> 优先返回。这样可以有效的减少分支泛滥的问题，同时也能使代码逻辑更加的清晰可读，因为在同一时间能总是只能做一件事情。</p>
<p>我们还可以在必要时优先 <code>return</code> 较短的逻辑块，使代码更加美观。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">    <span class="comment">// server code</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="comment">// client code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> render = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">if</span> (isServer) &#123;</span><br><span class="line">    <span class="comment">// server code</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// client code</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="4-不要过度优化"><a href="#4-不要过度优化" class="headerlink" title="4. 不要过度优化"></a>4. 不要过度优化</h1><p>如果你不是在编写类库、框架、底层代码等对性能要求极为苛刻的工程时，请务必过度以代码的可读性来换取代码的高效率。大多数的过度优化会让代码的可读性急剧下降，得不偿失！</p>
<ol>
<li>不必要的减少内存空间使用</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> fullname;</span><br><span class="line">users.forEach(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  fullname = user.firstname + user.lastname;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  register(fullname);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">users.forEach(<span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> fullName = user.firstname + user.lastname;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  register(fullname);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>不必要的运算优化</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">let</span> len = users.length;</span><br><span class="line"><span class="function"><span class="title">for</span>(<span class="params">i = <span class="number">0</span>; i &lt; len; i++&gt;</span>)</span> &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line">users.forEach(<span class="function"><span class="params">user</span> =&gt;</span> &#123;&#125;)</span><br></pre></td></tr></table></figure>

<h1 id="5-减少魔术字符"><a href="#5-减少魔术字符" class="headerlink" title="5. 减少魔术字符"></a>5. 减少魔术字符</h1><p>魔术字符串指的是，在代码之中多次出现，与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除这些魔术字符，改由清晰的变量代替。</p>
<p>而通常，我们还会把所有的字符或数字统一声明在一个常量的文件内，如 <code>host</code> <code>defaultSettings</code> <code>port</code> 等等，这将会有益于后期维护工作。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&quot;https://api.example.com&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;host&#125;</span>/1/users`</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> host = <span class="string">&quot;https://api.example.com&quot;</span>;</span><br><span class="line"><span class="keyword">const</span> apiVersion = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> apis = &#123;</span><br><span class="line">  users: <span class="string">&quot;users&quot;</span>,</span><br><span class="line">  goods: <span class="string">&quot;goods&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> url = <span class="string">`<span class="subst">$&#123;host&#125;</span>/<span class="subst">$&#123;apiVersion&#125;</span>/<span class="subst">$&#123;apis.users&#125;</span>`</span>;</span><br></pre></td></tr></table></figure>

<h1 id="6-函数不要有过多的参数"><a href="#6-函数不要有过多的参数" class="headerlink" title="6. 函数不要有过多的参数"></a>6. 函数不要有过多的参数</h1><p>在不断变动的需求中，我们编写的函数可能会有越来越多的参数。但要注意一点，当一个函数有较多的参数时，就会给调用方带来困扰。我们并非需要把每一个函数都实现 <strong>curry</strong>，但减少函数参数、合并参数、拆分函数功能都会让代码的可读性与拓展性更上一个台阶。</p>
<p>在调用较多参数的函数时，我们不仅要记住每个参数的位置，若有参数空缺时还需对其进行补位（如传入 <code>null</code> <code>undefined</code>），这会导致声明与调用的代码中都被迫存在非常多的冗余判断。所以在参数个数出现增长时，就可以考虑将其中的一部分合成一个参数对象，或是将函数内的功能进行拆分，作为一个新的函数。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">id, name, telephone, email, address, createBy</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> createUser = <span class="function">(<span class="params">id, userOptions</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<h1 id="7-保持函数的专注"><a href="#7-保持函数的专注" class="headerlink" title="7. 保持函数的专注"></a>7. 保持函数的专注</h1><p>在一个函数里最好只做一件事，同时最好让函数的名字与做的这件事与之相关联，尤为重要！在单个函数中累积逻辑，会给阅读者带来非常大的心智负担，如果我们尝试函数拆分、组合并合理化命名，将会使代码整体获得极大的美感。使代码井井有条，泾渭分明也是一门别样的艺术。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> header = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> options = <span class="comment">// ...</span></span><br><span class="line">    options.header = headers;</span><br><span class="line">    <span class="keyword">const</span> host = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">const</span> url = <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">if</span>(id.length &gt; <span class="number">1</span>) <span class="comment">// ...</span></span><br><span class="line">    <span class="keyword">return</span> fetch(url, options);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> makeOptions = <span class="function">() =&gt;</span> &#123; <span class="comment">// ... &#125;;</span></span><br><span class="line"><span class="keyword">const</span> makeUrl = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="comment">// ... &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function"><span class="params">id</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">const</span> options = makeOptions();</span><br><span class="line">    <span class="keyword">const</span> url = makeUrl(id);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> fetch(url, options);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="8-使用语义化命名代替冗长的判断条件"><a href="#8-使用语义化命名代替冗长的判断条件" class="headerlink" title="8. 使用语义化命名代替冗长的判断条件"></a>8. 使用语义化命名代替冗长的判断条件</h1><p>过长的判断条件可能会在编写的当下烂熟于心，但常常会在一段时间回头再看觉得匪夷所思，很难理解其中的逻辑。所以，将其使用语义化的常量代替则可以向阅读者提示其含义，更是省下了不必要的注释，可真是一举两得！</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断是否为青少年</span></span><br><span class="line"><span class="keyword">if</span> (user.age &lt; <span class="number">19</span> &amp;&amp; user.age &gt; <span class="number">13</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> isTeenAgeMember = user.age &gt; <span class="number">13</span> &amp;&amp; user.age &lt; <span class="number">19</span>;</span><br><span class="line"><span class="keyword">if</span> (isTeenAgeMember) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h1 id="9-减少函数的副作用"><a href="#9-减少函数的副作用" class="headerlink" title="9. 减少函数的副作用"></a>9. 减少函数的副作用</h1><p>减少函数副作用一直以来都是 JS 社区中的长青话题，特别是 React 社区，而减少副作用并非总是需要以纯函数来解决所有问题。所以无需紧张，我们知道副作用会使得状态变化难以捕捉，在编程中应当以编写较少的副作用函数为目标，使函数的预期与实际保持一致的同时又不会造成过多的“噪音”。虽然，这或许会在构思和声明阶段花费一些时间，但对于整体代码的质量来说，是一件以小换大的好事！</p>
<p>你可能会发现有些时候不可避免的引用并改变了函数外部的状态，比如缓存某些值，为此你陷入了重构的苦恼。事实上不必过于忧虑，你想做的必然有其道理。这就是<strong>编程中取舍</strong>的问题，学会在编程、架构、工程上有所取舍（并不是随心所欲）后构建出的产品，自然会带有一定的特色。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> user = getUser();</span><br><span class="line"><span class="keyword">const</span> upload = <span class="function">() =&gt;</span> &#123;</span><br><span class="line">  user.tempField = <span class="string">&quot;temp content&quot;</span>;</span><br><span class="line">  <span class="comment">// fetch user...</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> user = getUser();</span><br><span class="line"><span class="keyword">const</span> upload = <span class="function">(<span class="params">user</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">const</span> tempUser = &#123; ...user, <span class="attr">tempField</span>: <span class="string">&quot;temp content&quot;</span> &#125;;</span><br><span class="line">  <span class="comment">// fetch user...</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>更优雅的JavaScript 2</title>
    <url>/2020/02/04/more-elegant-javascript-2/</url>
    <content><![CDATA[<p>接着上一文，在<a href="/2019/12/13/more-elegant-javascript-1/">更优雅的 JavaScript 1</a>中，我们聊到了基础的 JavaScript 编程的建议。包括如何可靠的声明变量、常量、函数、以及利用合适的函数合适的构建逻辑，现在我们思考改善代码的第一步，如何命名？</p>
<p>在我们开始阅读代码之前，编码风格与命名方式会比代码的抽象方式、设计技巧更令我们印象深刻。很多时候也会为项目的整体风格定下基调。如果你阅读过一些算法工程师写的代码，常常会看到<del>单字母变量</del>、<del>反复的声明</del>，<del>不知所以的赋值与拷贝</del>、<del>累赘的条件判断</del>等等。我们虽不能说这样有问题，因为他们的代码大多的确是可以正常的运作，甚至在运行的时间或空间效率上有一些优势。但这在工程，特别是大型工程中是不值得称道的，根据经验我们可以把这类代码归类为“屎山”，充其量是“堆”了一摊高性能的“屎山”。</p>
<p>而我们现在做的则是脱离“编程只不过是工具”的阶段，脱离“屎山男孩”，让机器面有喜色、富有人性，使阅读者在某个瞬间也能切实的感受到创作者的思维跳动与审美哲学。</p>
<h1 id="1-富有准确性的命名"><a href="#1-富有准确性的命名" class="headerlink" title="1. 富有准确性的命名"></a>1. 富有准确性的命名</h1><p>事实上，你完全可以使用 <code>doSomeThing</code> 来命名所有的函数，毕竟它们真的只是提供某些微不足道的功能。但当你有了多个，甚至是成百上千个函数时，这将是一场灾难。这是一个浅显易懂的道理，即便是毫无经验的开发人员也会意识到命名爆炸的问题，他们隐约明白了什么是好的编程风格。但最后，甚至是大多数都止步于 <code>doSomeThing</code> 到“优美”之前的某一个站上。然后他们心里就默念，这就够了。</p>
<ol>
<li> 命名只需要有必要的词，除非有不要，否则不要堆砌</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> theBook = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> _book = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> bookObj = &#123;&#125;;</span><br><span class="line"><span class="keyword">const</span> theNewBook = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可读的条件判断</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">if</span> (username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>)) &#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> prefix = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> availableName = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> hasPrefixName = username &amp;&amp; username.includes(<span class="string">&quot;prefix-&quot;</span>);</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>可读的函数</li>
</ol>
<p>当我们要从网络上获取用户信息时，<code>getUser</code> 就不是一个准确的表达，<code>get</code> 太过于宽泛，它该表示是从数据库获取还是从网络获取？是以用户名获取还是用 ID 获取？这都有区别，现在我们可以先从命名的层面上思考它们的区别：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> getUser = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> fetchUserByName = <span class="function">(<span class="params">name</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> findOneUserByID = <span class="function">(<span class="params">id</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good(any environment, any params)</span></span><br><span class="line"><span class="keyword">const</span> getUsers = <span class="function">(<span class="params">...params</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>准确的表达</li>
</ol>
<p>属性可以避免不必要的描述，言简意赅：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  bookname: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  length: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> book = &#123;</span><br><span class="line">  title: <span class="string">&quot;&quot;</span>,</span><br><span class="line">  pages: <span class="string">&quot;&quot;</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>注意单复数：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> book = findBooks();</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> books = findBooks();</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>不必要的约定</li>
</ol>
<p>通常在示例或无意义的遍历中，我们会把每一个回调函数的参数写作 <code>item</code> <code>value</code> <code>element</code> 等等，这在一些场景中的确可以让阅读者忽略掉不必要的描述，从而专注于逻辑本身。但这并非总是合适，特别是我们需要表达状态的时候：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> titles = books</span><br><span class="line">  .map(<span class="function">(<span class="params">item</span>) =&gt;</span> item.title)</span><br><span class="line">  .filter(<span class="function">(<span class="params">item</span>) =&gt;</span> item.length &gt; <span class="number">0</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> titles = books</span><br><span class="line">  .map(<span class="function">(<span class="params">book</span>) =&gt;</span> book.title)</span><br><span class="line">  .filter(<span class="function">(<span class="params">title</span>) =&gt;</span> title.length &gt; <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<h1 id="2-观察与思考"><a href="#2-观察与思考" class="headerlink" title="2. 观察与思考"></a>2. 观察与思考</h1><p>观察是一个模糊的概念，可以尝试让同事朋友阅读你的代码，问问他们的感觉，那些命名生硬，哪些词不达意，哪些又能让他们感同身受。一个可学习的方式就是在 <code>GitHub</code> 上阅读代码，你也能注意到开发者们的情绪波动，这里真的需要这些定义吗？这里有必要写的这么短小精悍吗？这里是不是写的太过于 <code>OC</code> 风了。试图从阅读代码理解开发者创作时的想法是很有趣的一件事件，这些情绪的波动可以还能让你明白他们大约处于编程、人生、情感的什么状态，有助于你深刻的理解接口与设计。</p>
<p>在一个项目中见到 <code>created</code> 时，便可以知道这调用在 <code>create</code> 之后，而非之前或者之中。以此类推便可以有 <code>destroyed</code> 或其他函数。如果项目是来自富有经验的开发者，这些细节会帮助你在代码中极快的理解作者的构思。</p>
<p>在阅读某些源码时，我们可能会注意到一些细节，就是一些旧有的功能被改变了，程序员只能被迫去修改这些已有的接口使之兼容。同时想要与原有的风格保持一些同步，有时也会衍生出一些新的接口，他们被置于一些结构体中，随着时间的推移可以推理，未来的一些接口也会被移入这些结构体 ———— 这就是我们对于命名的观察与思考。我曾经看见过有人说“狗是人类的朋友，taobao 的文档连狗都不如”，这就是他们观察的结果了，虽然好像令人不那么开心。</p>
<h1 id="3-巧妙与投机取巧"><a href="#3-巧妙与投机取巧" class="headerlink" title="3. 巧妙与投机取巧"></a>3. 巧妙与投机取巧</h1><p>我们可以断定<strong>巧妙</strong>是优雅命名中最重要的一部分，比如 <code>rvm</code> 与其他的一些命令行工具中的 uninstall 功能，其命令为 <code>implode</code> 。这好像有点意思，是吧？但事实上我见到的绝大多数的巧妙不过是“投机取巧”，他们苦心孤诣的作品是一大段没有说明的八进制、二进制代码，一堆三元堆砌的单行逻辑，一些谐音名字，以及不合时宜的正则表达式等等，这并不漂亮，这是歧路。</p>
<ol>
<li>自作聪明的谐音</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> markdowm2html = <span class="function">(<span class="params">template</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> markdownToHmtl = <span class="function">(<span class="params">template</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>

<ol start="2">
<li>可以语义化的正则</li>
</ol>
<p>代码并非是越简短越好，虽然多数场景下，我们需要尽可能的避免长篇累牍。但在必要时，可以使用命名和语义化的代码块来试图说明逻辑：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> isUser = <span class="regexp">/^name/</span>.test(user.name) &amp;&amp; <span class="regexp">/^http/</span>.test(user.url);</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> isUserName = user.name.startWith(<span class="string">&quot;name&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isUrl = user.blog.startWith(<span class="string">&quot;http&quot;</span>);</span><br><span class="line"><span class="keyword">const</span> isUser = isUserName &amp;&amp; isUrl;</span><br></pre></td></tr></table></figure>

<ol start="3">
<li>优美</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="comment">// bad</span></span><br><span class="line"><span class="keyword">const</span> hasDirOrCreateDir = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// good</span></span><br><span class="line"><span class="keyword">const</span> ensureDir = <span class="function">(<span class="params">path</span>) =&gt;</span> &#123;&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
        <tag>代码风格</tag>
      </tags>
  </entry>
  <entry>
    <title>粗解TCP的流量控制和拥塞控制</title>
    <url>/2019/06/30/tcp-traffic-and-congestion-control/</url>
    <content><![CDATA[<h1 id="流量控制"><a href="#流量控制" class="headerlink" title="流量控制"></a>流量控制</h1><h2 id="1-什么是流量控制"><a href="#1-什么是流量控制" class="headerlink" title="1. 什么是流量控制"></a>1. 什么是流量控制</h2><p>在 TCP 传输中，如果数据发送方的发送速度过快，那么就会造成数据接收方来不及接收所有发送出的数据。那么在这样的状况下，就会有分组丢失的情况发生。控制数据发送方的发送速度，使得数据接收方来得及接收，这就是流量控制。</p>
<h2 id="2-流量控制的目的"><a href="#2-流量控制的目的" class="headerlink" title="2. 流量控制的目的"></a>2. 流量控制的目的</h2><p>流量控制的其根本目的就是防止 TCP 传输中的分组丢失，它是构成 TCP 可靠性传输的其中一个方面。</p>
<h2 id="3-如何实现流量控制"><a href="#3-如何实现流量控制" class="headerlink" title="3. 如何实现流量控制"></a>3. 如何实现流量控制</h2><p>TCP 传输的流量控制由<strong>滑动窗口协议</strong>（<a href="https://zh.wikipedia.org/wiki/%E8%87%AA%E5%8A%A8%E9%87%8D%E4%BC%A0%E8%AF%B7%E6%B1%82"><strong>连续 ARQ 协议</strong></a>）实现的，滑动窗口协议既能保证分组无差错、有序接收，也实现了流量控制的功能。主要的方式就是接收方在返回的 ACK 中会包含自己的接收窗口大小，并利用该接收窗口大小来实现控制发送方的数据发送。</p>
<a id="more"></a>

<hr>
<h1 id="拥塞控制"><a href="#拥塞控制" class="headerlink" title="拥塞控制"></a>拥塞控制</h1><h2 id="1-什么是拥塞控制"><a href="#1-什么是拥塞控制" class="headerlink" title="1. 什么是拥塞控制"></a>1. 什么是拥塞控制</h2><p>拥塞控制是一种用来调整 TCP 链接单次发送分组数量（<strong>单次发送量</strong>，通常叫 cwnd）的算法</p>
<h2 id="2-拥塞控制的目的"><a href="#2-拥塞控制的目的" class="headerlink" title="2. 拥塞控制的目的"></a>2. 拥塞控制的目的</h2><p>拥塞控制的其根本目的是防止通信子网中某一部分的分组数量过多，使得该部分的网络来不及处理，导致该通讯子网乃至整个网络性能下降的现象发生。严重的话还会导致网络通信业务陷入停顿，既出现死锁的现象。</p>
<p>其实就是类似于平时深圳公路网中常见的交通拥挤一样，当节假日出行的车辆大量增加时，各种走向的车流互相干扰。不仅如此，还有各路段不停修路，最终导致的堵车。</p>
<h2 id="3-如何实现拥塞控制"><a href="#3-如何实现拥塞控制" class="headerlink" title="3. 如何实现拥塞控制"></a>3. 如何实现拥塞控制</h2><p>在讲如何实现拥塞控制之前，需要介绍两个概念，第一个就是<strong>拥塞窗口 cwnd</strong>（<strong>congestion window</strong>），而第二个则是慢开始门限 <strong>ssthresh</strong>（<strong>slow start thresh</strong>）。<strong>后面的内容将会用 cwnd 和 ssthresh 代指它们两个</strong>，下面是对这两个概念的具体解释：</p>
<ol>
<li><p>发送方会维持一个拥塞窗口的状态变量，拥塞窗口的大小取决于网络的拥塞程度，并且会根据实际情况动态变化。发送方让自己的发送窗口大小等于拥塞窗口大小，另外考虑到接收方的接受能力，发送方的发送窗口可能还需要小于拥塞窗口。</p>
</li>
<li><p>为了防止拥塞窗口增长过快，发送方还会维持一个慢开始门限变量，一旦到达慢开始门限的值后就会从慢开始算法转为执行拥塞避免算法。</p>
</li>
</ol>
<h3 id="1-慢开始算法"><a href="#1-慢开始算法" class="headerlink" title="1) 慢开始算法"></a>1) 慢开始算法</h3><p>慢开始算法的思路就是，不要一开始就发送大量的数据，先探测一下网络的拥塞程度，也就是由小到大逐渐增加 cwnd 的大小。从下图可以看到，一个传输轮次所经历的时间其实就是往返时间 RTT，而且每经过一个传输轮次，cwnd 就加倍。所以慢开始里的“慢”并不是指 cwnd 增长的速率慢，而是指在 TCP 传输开始发送报文段时，初始设置的 cwnd 较小，然后再指数式增大。这当然会比，在初始就设置为较大的 cwnd 一下子把许多报文段注入到网络中要“慢的多”。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201026180823.png" alt="慢开始算法"></p>
<p>为了防止慢开始算法，让 cwnd 走上无止境的指数式增长的道路，上面提到的 ssthresh 就起到了关键的作用。ssthresh 的具体作用如下，所以在这里可以看出慢开始算法和拥塞避免算法在拥塞控制中是相辅相成的：</p>
<ol>
<li>当 <strong>cwnd &lt; ssthresh</strong> 时，就执行慢开始算法；</li>
<li>当 <strong>cwnd &gt; ssthresh</strong> 时，就改为执行拥塞避免算法；</li>
<li>当 <strong>cwnd = ssthresh</strong> 时，慢开始与拥塞避免算法任选。</li>
</ol>
<h3 id="2-拥塞避免算法"><a href="#2-拥塞避免算法" class="headerlink" title="2) 拥塞避免算法"></a>2) 拥塞避免算法</h3><p>拥塞避免算法的思路就是让 cwnd 缓慢增长，即每经过一个往返时间 RTT 就把发送方的 cwnd +1，而不是指数式的加倍。这样有助于 cwnd 按线性规律的缓慢增长。另外无论是在慢开始算法阶段还是拥塞避免算法阶段，只要发送方判断网络出现拥塞（主要是根据有没有定时的收到接收方的确认，虽然没有收到确认可能是其他原因造成的。但是无法判断具体原因，所以都当做拥塞来进行处理），就把 ssthresh 设置为出现拥塞时的发送窗口大小的一半（但不能小于 2），然后把 cwnd 重新置为 1，然后改为执行慢开始算法（这样做的目的是要迅速减少发送方发送到网络中的分组数，使得拥塞的网络中的路由器有足够的时间把积压的分组处理完毕）。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201026183338.png" alt="拥塞避免算法"></p>
<ol>
<li>cwnd 初始化为 1 个报文段，ssthresh 初始值为 16</li>
<li>开始执行慢开始算法，指数增长到第 4 轮，既 cwnd=ssthresh=16，然后改为执行拥塞避免算法，cwnd 按加法增长（线性规律增长）</li>
<li>假定 cwnd=24 时，网络出现超时（拥塞），则设置 ssthresh 为出现拥塞时的发送窗口大小的一半，既 ssthresh=12，cwnd 重新设置为 1，然后改为执行慢开始算法。当 cwnd=ssthresh=12 时，为避免拥塞，改为执行拥塞避免算法</li>
</ol>
<h3 id="2-快重传算法"><a href="#2-快重传算法" class="headerlink" title="2) 快重传算法"></a>2) 快重传算法</h3><p>快重传算法的思路就是要求接收方在收到 1 个失序的报文段后就立即发出重复确认（为的是让发送方及早知道有报文段没有到达）。快重传算法规定，发送方只要一连收到 3 个重复确认（确认丢失段的前一个段）就应当立即重传对方尚未收到的报文段，而不必继续等待设置重传计时器时间到期。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201026185311.png" alt="快重传算法"></p>
<h3 id="4-快恢复算法"><a href="#4-快恢复算法" class="headerlink" title="4) 快恢复算法"></a>4) 快恢复算法</h3><p>快重传算法一般与快恢复算法配合使用，快恢复算法的思路就是当发送方连续收到 3 个重复确认时，就执行“乘法减少”算法，设置 ssthresh 为遇到突发情况时发送窗口大小的一半预防网络发生拥塞，考虑到如果网络出现了拥塞就不会接收到好几个重复确认，所以发送方认为现在网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将 cwnd 设置为 ssthresh 减半后的值，然后改为执行拥塞避免算法，使 cwnd 缓慢增长。</p>
<p><img src="https://cdn.jsdelivr.net/gh/aaronlam/imghosting/20201026190649.png" alt="快恢复算法"></p>
<hr>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>流量控制主要作用于接收方，它是控制发送方的发送速度从而使接受方能够来的急接收发送方所发送的数据，防止分组丢失的控制方法。由<strong>滑动窗口协议</strong>（<strong>连续 ARQ 协议</strong>）实现，滑动窗口协议既保证了分组无差错、有序接收，也实现了流量控制的功能。<br>拥塞控制则作用于网络，它是防止过多的数据注入到传输的网络中，避免网络负载过大的情况发生。常用的控制方法如下：</p>
<ol>
<li>慢开始算法+拥塞避免算法</li>
<li>快重传算法+快恢复算法</li>
</ol>
<p>另外，慢开始算法只是在 TCP 传输建立时和网络出现超时时才使用。</p>
]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>TCP</tag>
        <tag>网络</tag>
        <tag>流量控制</tag>
        <tag>拥塞控制</tag>
      </tags>
  </entry>
</search>
